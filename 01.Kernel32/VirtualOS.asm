[ORG 0x00]		;코드의 시작 어드레스를 0x00으로 설정
[BITS 16]		;이하의 코드는 16비트 코드로 설정
SECTION .text	;text섹션을 정의

jmp 0x1000:START	;CS세그먼트 레지스터에 0x1000을 복사하면서 START레이블로 이동

SECTORCOUNT:		dw 0x0000	;	현재 실행중인 섹터 번호를 저장
TOTALSECTORCOUNT:	equ 1024	;	가상 OS의 총 섹터수
								;	최대 1152섹터 까지 가능
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	코드 영역
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
	mov ax, cs		;cs 세그먼트 레지스터의 값을 ax레지스터에 설정
	mov ds, ax		; AX레지스터의 값을 ds세그먼트 레지스터에 설정
	mov ax, 0xB800	;	비디오 메모리 어드레스인 0x0B8000을 세그먼트 레지스터값으로 변환
	mov es, ax		;	ES세그먼트 레지스터에 설정
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	각섹터별로 코드를 생성
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	%assign i	0	;i라는 변수를 지정하고 0으로 초기화
	%rep TOTALSECTORCOUNT	;TOTALSECTORCOUNT에 저장된 값만큼 아래 코드를 ㅏㅂㄴ복
		%assign i	i+1		;i 를 1증가
		;현재 실행중인 코드가 포함된 섹터의 위치를 화면 좌표로 변환
		mov ax,2		;	한문자를 나타내는 바이트수 를 AX레지스터에 설정
		mul word[ SECTORCOUNT ]			;AX레지스터와 섹터수를 곱함.
		mov si, ax		;곱한 결과를 si레지스터에 설정
		mov byte [es: si+(160*2)], '0'+(i % 10)
										;계산된 결과를 비디오 메모리에 오프셋으로 삼아 세번째라인부터 화면에 0을 출력

		add word [SECTORCOUNT],1		;섹터수를 1증가.

		;	마지막 섹터이면 더 수행할 섹터가 없으므로 무한 루프 수행 그렇지않으면 다음 섹터로 이동해서 코드 수행
		%if i == TOTALSECTORCOUNT	;	I가 토탈 카운트와같다면(마지막 섹터이면)
			jmp $			; 현재위치에서 무한루프
		%else				; 마지막 섹터가 아니라면
			jmp ( 0x1000 +i*0x20):0x0000; 다음 섹터 오프셋으로 이동
		%endif				; end문의 끝
		times (512 - ($-$$) % 512 )  db 0x00	;$현재 라인의 어드래스 $$현재 섹션
									;( .text)의 시작 어드레스
									;$-$$은 현재 섹션을 기준으로 하는 오프셋
									;512 -($-$$) 현재부터 어드레스 512까지
									;db 0x00: 1바이트를 선언하고 값은0x00
									;time : 반복수행
									;현재위치에서 어드레스 512까지 0x00으로 채움.
									;반복문의 끝;% assign i 0 : i라는 변수를 지정하고 0으로 설정 i =0과 동일;%rep TOTALSECTORCOUNT : $endrep까지의 라인은 TOTALSECTORCOUNT만큼 반복하면서 삽입;%assign i i+1		:	i=i+1과 동일
									;%if i == TOTALSECTOROUNT: 마지막섹터이면
								;%else ,endif times;;;;;; %endrep : rep블록 종료.
	%endrep
