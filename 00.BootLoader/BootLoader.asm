[ORG 0x00]	; 코드의 시작 어드레스를 0x00으로 설정 부트로더를 메모리에 정상적으로 복사하려면 한가지 부트섹터 512바이트중 마지막 2바이트를 0x55 0xAA에 저장하면됩니다
[BITS 16]	; 이하의 코드는 16비트 코드로 설정

SECTION .text	; text 섹션을 정의

jmp 0x07C0:START	; 현재 위치에서 무한루프 수행
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	MINT64 OS에 관련된 환경 설정 값
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TOTALSECTORCOUNT:	dw	1024	;부트 로더를 제외한 MINT64의 크기 최대 1152섹터(0x90000byte)까지 가능.
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	코드 영역
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
	mov ax, 0x07C0	; AX레지스터에 시작어드레스를 레지스터값으로전환
	mov ds, ax		; DS세그먼트 레지스터에 AX 레지스터의 값을 복사
	mov ax, 0xB800	; 비디오메모리 시작어드레스를 세그먼트레지스터값으로 변환
	mov es, ax		; ES세그먼트 렞스터에 설정


	;스택을 0x0000:0000~0ㅌ0000:FFFF영역에 64KB로 생성
	mov	ax,	0x0000	;스택 세그먼트의 시작 어드레스를 세그먼트 레지스터 값으로 변환
	mov ss, ax		; SS세그먼트 레지스터에 설정
	mov sp,	0xFFFE	; SP 레지스터의 어드레스를 0xFFFE로 설정
	mov bp,	0xFFFE	; BP 레지스터의 어드레스를 0xFFFE로 설정
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;화면을 모두 지우고 속성값을 녹색으로 설정함.
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov si,	0		; SI레지스터 를 초기화
.SCREENCLEARLOOP
	mov byte [ es: si],0;화면을 지우는 루프
						;비디오 ㅔ모리의 문자가 위치하는 어드레스에 0복사하여 문자를 복제
	mov byte [ es: si+1], 0x0A	;비디오 메모리에 속성이 위치하는 어드레스에 0x0A 검은바탕에 밝은녹색을 복사
	add si,2					; 문자와 속성을 설정했으므로 다음 위치로 이동

	cmp si, 80*25*2				;화면 전체의 크기는 80문자 *25 라인임 이후 출력한 문자의 수를 의미하는 si레지스터와 비교
	jl .SCREENCLEARLOOP			;냐fpwltmxjrk 80 25 2 보다 작다면ㅇ 아직 지우지 못한 영영ㄱ이 있으므로 .scrloop레이블ㄹ로 이동

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	화면 상단에 시작 메시지 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push MESSAGE1		;	출력할 메세지의 어드레스를 스택에 삽입
	push 0				;	화면 좌표 0 을 스텍에 삽입(Y)
	push 0				;	화면 좌표 0 을 스택에 삽입(X)
	call PRINTMESSAGE	;	PRINTMESSAGE 함수 호출
	add sp,6			;	삽입한 파라미터 제거
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	OS이미지를 로딩한다는 메시지 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push IMAGELOADINGMESSAGE	;출력할 메세지의 어드레스를 스택에 삽입
	push 1						;화면 Y좌표 를 스택에 삽입
	push 0						;화면 X좌표를 스택에 삽입
	call PRINTMESSAGE			;Printmessage 함수 호출
	add sp, 6					;삽입한 파라미터 제거
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	디스크에서 OS이미지를 로딩
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	디스크를 읽기 전에 먼저 리셋
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESETDISK: ; 디스크를 리셋하는 코드의 시작
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	BIOS 리셋 펑션 호출
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;서비스 번호 0 드라이브번호 0=플로피디스크
	mov ax, 0
	mov dl, 0
	int 0x13
	; 에러 발생시 처리로 이동
	jc HANDLEDISKERROR

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	디스크에서 섹터를 읽음
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스크의 내용을 메모리로 복사할 어드레스를 0x10000으로 설정
	mov si, 0x10000			;OS이미지를 복사할 어드레스 를
	mov es, si						; 세그먼트 레지스터 값으로 변환
	mov bx, 0x0000					; ES세그먼트 레지스터에 값설정,BX레지스터에  0x0000을 설정하여 복사함 어드레스를 0x1000:0000 (0x10000)으로 최종설정.

	mov di, word [TOTALSECTORCOUNT ] ;복사할 OS 이미지의 섹터수를 DI 레지스터에 설정.
READDATA:							;디스크를 읽는 코드의 시작
	;모든 섹터를 다 읽었는지 확인
	cmp di,0						;복사할 OS의 이미지의 섹터수를 0 과 비교
	je	READEND						; 복사할 섹터수가 0 이라면 다 복사 했으므로 READEND로 이동
	sub	di,0x1						;복사할 섹터수를 1감소
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	BIOS Read Function호출
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov ah,0x02						; BIOS서비스 번호 2
	mov al,0x01						;읽을 섹터수는 1
	mov ch, byte[TRACKNUMBER]		;읽을 트랙 번호 설정
	mov cl, byte[SECTORNUMBER]		;읽을 섹터 넘버 설정
	mov dh, byte[HEADNUMBER]		;읽을 헤드 번호 설정
	mov dl, 0x00					;읽을 드라이브 번호 설정
	int 0x13						;start interrupt service
	jc HANDLEDISKERROR				;에러가 발생했다면 핸들 디스크 에러로 이동

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	복사할 어드레스와 트랙 헤드 섹터 어드레스 계산
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	add si, 0x0020		;512 (0x200)바이트만큼 읽었으므로 이를 세그먼트 레지스터 값으로 변환
	mov es, si			;ES세그먼트 레지스터에 더해서 어드레스를 한섹터만큼 증가
	;한 섹터를 읽었으므로 섹터번호를 증가시키고 마지막 섹터 까지 읽었는지 판단한다.
	;마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터읽기 수행.
	mov al, byte[SECTORNUMBER]	;섹터번호를 AL레지스터에 저장
	add al, 0x01				;섹터번호를 1증가
	mov byte [ SECTORNUMBER ], al;증가시킨 섹터 번호를 섹터넘버에 다시 설정
	cmp al, 19 					; 증가시킨 섹터 번호를 19와 비교하여 19보다 작으면 READDATA로 이동
	jl READDATA					;
	; 마지막까지 읽었다면 헤드를 토글하고 섹터번호를 1로 설정한다.
	xor byte [ HEADNUMBER ],0x01		; 헤드 번호를 0x01과 XOR하여 토글
	mov byte [ SECTORNUMBER ],0x01		; 섹터 번호를 다시 1 로 설정
	;만약 헤드가 1~0으로 바뀌었으면 양쪽헤드를 모두 읽은 것이므로 아래로 이동하여 트랙번호를 1증가
	cmp byte [HEADNUMBER],0x00			; 헤드번호를 0x00과 비교
	jne READDATA			; 헤드번호가 0이 아니면 READDATA로 이동

	;트랙을 1 증가시킨후 다시 섹터 읽기로 이동
	add byte[TRACKNUMBER],0x01		;트랙 번호를 1증가
	jmp READDATA					;READDATA로 이동
READEND:
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	OS이미지가 완료되었다는 메세지를 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push LOADINGCOMPLETEMESSAGE	;	출력할 메시지의 어드레스를 스택에 삽입
	push 1						;	화면좌표 y = 1을 삽입
	push 20						;	화면좌표 x = 20을 삽입
	call PRINTMESSAGE			;	함수호출
	add sp,6					;	삽입한 파라미터 제거

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	로딩한 가상 OS이미지 실행
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	jmp 0x1000:0x0000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	함수 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 디스크 에러를 처리하는 함수
HANDLEDISKERROR:
	push DISKERRORMESSAGE	;	에러 문자열의 어드레스를 스택에 삽입
	push 1					;	y 를 삽입
	push 20					;	x삽입
	call PRINTMESSAGE		;	 힘수호출

	jmp $					;	현재위치에서 무한루프 수행
; 메세지를 출력하는 함수
; PARAM: x, y , 문자열
PRINTMESSAGE:
	push bp					;	베이스 포인터 레지스터를 스택에 삽입.
	mov bp,sp				;	베이스 포인터 레지스터에 스택 포인터 레지스터의 값을 설정

	push es					;	es 세그먼트 레지스터부터 dx레지스터까지 스택에 삽입
	push si					;	함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래값으로 복원
	push di					;
	push ax
	push cx
	push dx
	;es세그먼트 레지스터에 비디오모드 어드레스 설정
	mov ax, 0xB800			;	비디오 메모리 시작 어드레스를 세그먼트 레지스터값으로 변환
	mov es, ax 				;	ES 세그먼트 레지스터에 설정.
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	X,Y 의 좌표로 비디오 메모리의 어드레스를 계산함.
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;Y좌표를 이용해서 먼저라인 어드레스를 계산함.
	;mov si, 0					;SI레지스터 를 초기화(문자열 원본 인덱스 레지스터)
	;mov di, 0					;디아이 레지스터 를 초기화( 문자열 대상 인덱스 레지스터)
	mov ax,word[bp +6]			;파라미터 2 화면좌표 y를 ax레지스터에 설정.
	mov si,160					;한문자를 나타내는 바이트수를 (2) SI레지스터에 설정
	mul si						;AX레지스터와 SI레지스터를 곱하여 화면 X어드레스를 더해서
	mov di,ax					;실제 비디오 메모리 어드레스를 계산

	;출력할 문자열의 어드레스
	mov si, word[bp +8] 		;파라미터 3(출력할 문자열의 어드레스)

.MESSAGELOOP:
	mov cl, byte[si]	; message의 어드레스에서 레지스터값만큼 더한위치의 문자를cl 레지스터에 복사하며 CL레지스터는 CX레지스터의 하위1바이트를 의미,
								; 문자열은 1바이트면 출분하므로 CX레지스터듸 하위 1바이트만 사용  원랜 mov cl, byte[si + MESSAGE1]
	cmp cl, 0					;복사된 문자와 0을 비교
	je .MESSAGEEND				; 복사한 문자의 값이 0이면 무자열이 종료되었음을 의미하므로 .MESSAGEEND이동하여 문자출력종료

	mov byte [es: di], cl		;0이 아니면 비디오 메모리 어드레스 0xB800:di에 문자를 출력

	add si, 1					;SI레지스터에 1을 더하여 다음 문자열로 이동
	add di, 2					;DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동
								;비디오 메모리는 문자 속성쌍으로 구성되므로 문자만 출력하려면 2를 더해야 함
	jmp .MESSAGELOOP			;메세지 출력 루프로 이동하여 다음 문자를 출력
.MESSAGEEND:
	pop dx			;함수에서 사용이 끝난 DX~ES 레지스터를 스텍에 삽입된 값을 이용해 복원
	pop cx			;
	pop ax			;
	pop di			;
	pop si			;
	pop es
	pop bp			; 베이스 포인터 레지스터 복원
	ret				; 함수를 호출한 다음 코드의 위치로 복귀
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	데이터 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	부트로더 시작 메시지
MESSAGE1:	db 'MINT64 OS Boot Loader Start~!!',0	;출력할 메세지 정의
													;마지막은 0으로 설정하여 메세지루ㅡ에서 문자열이 종료되었음을 알 수 있도록 함.
DISKERRORMESSAGE:			db	'DISK ERROR',0
IMAGELOADINGMESSAGE:		db	'OS IMAGE Loading...',0
LOADINGCOMPLETEMESSAGE:		db	'Complete',0

;디스크 읽기와 관련된 변수들
SECTORNUMBER: 				db	0x02	;	OS이미지가 시작하는 섹터 번호를 저장하는 영역
HEADNUMBER:					db	0x00	;				헤드번호
TRACKNUMBER:				db	0x00	;				트랙번호


;
;mov byte[0x00], 'M'		; DS 세그먼트 오프셋 0XB800:0x0000에 M을 복사
;mov byte[0x01], 0x4A	; DS세그먼트 오프셋 0xB800: 0x0001에 0x4A 빨간배경에 밝은 녹색 속성을 복사




times 510 - ($ - $$)	db	0x00	; $: 현재 라인의 어드레스
									; $$:현재섹션의 시작어드레스
									; $-$$
									; 510-($-$$) 현재부터 어드레스 510까지
									; db 0x00 1바이트를 선언하고 값은 0x00
									; time: 반복수행
									; 현재 위치에서 어드레스 510까지 0x00으로 채움
db 0x55			; 1바ㅣ트를 선언하고 값은 0x55
db 0xAA			; 1바이트를 선언하고 값은 0xAA
				; 어드레스 511,512dp 0x55 0xAA를 써서 부트섹터로 표기함
